<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>ortools_utils.explainability.negative_explanations API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>ortools_utils.explainability.negative_explanations</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from multiprocessing import Process, Queue
from typing import *
import logging

from ortools.sat.python import cp_model

from ortools_utils.model_indexation.constraints import NamedBlock, UsualConstraint
from .constraints_relaxation import ConstraintsRelaxation
from .consistency import is_consistent

logger = logging.getLogger(__name__)
logging.basicConfig(level=logging.WARNING)


class NegativeExplanation:
    &#34;&#34;&#34;
    Class for generating the explanation of an unsolvable model.
    &#34;&#34;&#34;

    def __init__(
            self,
            model,
            split_choice=3,  # Argument explaining how we split the set of constraints in two
            nb_iis_granularite=1
    ):
        self.model = model
        self.dict_indexing = model.dict_indexing()
        self.nb_iis_granularite = nb_iis_granularite

        self.constraints_relaxation = ConstraintsRelaxation(model)
        self.solver = cp_model.CpSolver()

        self.index_var_assumption_to_block: Dict[int, NamedBlock] = dict()
        self.block_to_index_var_assumption: Dict[NamedBlock, int] = dict()
        self.list_idx_usual_constraints_with_assumptions = []
        self.list_idx_constant_constraints_with_assumptions = []
        self.variables_ajoutees = []

        self.list_already_found_iis = []

        self.split_choice = split_choice

    def is_infeasible(self) -&gt; bool:
        &#34;&#34;&#34;Before searching for IIS, checks once and for all that the model is not feasible&#34;&#34;&#34;
        self.model.Proto().ClearField(&#34;objective&#34;)
        return not is_consistent(self.model, self.solver)

    def find_one_iis_combined(self) -&gt; [NamedBlock]:
        &#34;&#34;&#34;Launches QuickXplain and Sufficient Assumption on two separate threads
        Returns the first result&#34;&#34;&#34;

        def thread_qx():
            logger.debug(&#39;Launching QuickXplain&#39;)
            res = self.find_one_iis_auto_zoom_quick_xplain()
            logger.debug(&#39;QuickXplain is done&#39;)
            return res

        def thread_sa():
            logger.debug(&#39;Launching Sufficient Assumption&#39;)
            res = self.find_one_iis_sufficient_assumption()
            logger.debug(&#39;Sufficient Assumption is done&#39;)
            return res

        class CustomProcess(Process):
            def __init__(self, tache, queue_de_retour):
                Process.__init__(self)
                self.tache = tache
                self.queue_de_retour = queue_de_retour

            def run(self):
                resultat = self.tache()
                self.queue_de_retour.put(resultat)

        queue_pour_le_resultat = Queue()
        liste_de_process = [CustomProcess(tache, queue_pour_le_resultat) for tache in [thread_qx, thread_sa]]

        for idx, process in enumerate(liste_de_process):
            process.start()

        resultat = queue_pour_le_resultat.get()

        for process in liste_de_process:
            process.terminate()

        return resultat

    def find_one_iis_sufficient_assumption(self) -&gt; [NamedBlock]:
        &#34;&#34;&#34;
        Finds one IIS with the Sufficient Assumption way
        Also uses a little Quick Xplain because SA does not handle constant constraints
        &#34;&#34;&#34;
        if not self.is_infeasible():
            logger.info(&#39;Problem is solvable&#39;)
            return None

        mon_iis_uc = self._find_one_iis_and_zoom(&#39;sufficient_assumption&#39;)
        if not mon_iis_uc:
            mon_iis_uc = []

        logger.info(&#39;IIS found with sufficient assumption :&#39;)
        logger.info(mon_iis_uc)
        logger.info(&#39;Reducing the IIS with quick xplain... &#39;)

        self.constraints_relaxation.relax_all_real_constraints_but(mon_iis_uc)

        # Finds one IIS with sufficient assumption
        mes_blocks = mon_iis_uc + [b for b in self.dict_indexing.return_all_blocks_as_named() if not b.is_true_constraint()]
        mon_iis_complet = self._find_one_iis_and_zoom(&#39;quick_xplain&#39;, mes_blocks)

        logger.info(&#39;Final IIS:&#39;)
        logger.info(mon_iis_complet)

        return mon_iis_complet

    def _find_one_iis_and_zoom(self, method: str, all_blocks=None) -&gt; [NamedBlock]:
        &#34;&#34;&#34;
        Finds one IIS on self.model (some constraints may be released)
        Zooms automatically to return an IIS with the most appropriate granularity
        At the end of this function, relaxed blocks are exactly the same as in the beginning
        &#34;&#34;&#34;
        if not all_blocks:
            all_blocks = self.dict_indexing.return_all_blocks_as_named()

        # Granularité initiale
        current_iis = self.find_iis_single_call(method, all_blocks)  # Liste de NamedBlock
        if len(current_iis) == 0:
            logger.info(&#39;There is a problem within the background blocks&#39;)
            return []

        # On relache une fois pour toutes ce qui n&#39;est pas dans l&#39;IIS
        self.constraints_relaxation.relax_all_but(current_iis, method)

        logger.info(&#39;Large IIS: &#39;)
        logger.info(current_iis)

        while True:
            longueur_iis = len(current_iis)
            nouv_iis = None
            new_blocks = None
            for nb in current_iis:
                while nb.can_be_split() and not new_blocks:
                    list_nb = nb.split_on_next_dimension()
                    new_blocks = list_nb + [b for b in current_iis if b != nb]
                    logger.debug(&#39;New blocks : {}&#39;.format(new_blocks))
                    nouv_iis = self.find_iis_single_call(method, new_blocks)
                    logger.debug(&#39;New-scale IIS : {}&#39;.format(nouv_iis))
                    if len(nouv_iis) &gt; longueur_iis + self.nb_iis_granularite - 1:
                        logger.debug(&#39;This dimension is not relevant&#39;)
                        nb.remove_dim_to_split()
                        nouv_iis = None
                        new_blocks = None
            if not nouv_iis:
                break
            else:
                current_iis = nouv_iis
                self.constraints_relaxation.relax_all_but(current_iis, method)
                logger.info(&#39;Current IIS: &#39;)
                logger.info(current_iis)

        logger.info(&#39;Final IIS:&#39;)
        logger.info(current_iis)
        self.constraints_relaxation.inv_relax_all()
        return current_iis

    def find_one_iis_auto_zoom_quick_xplain(self) -&gt; [NamedBlock]:
        &#34;&#34;&#34;
        Finds one IIS by zooming automatically with QX method
        Starts by finding MacroBlocks that are in conflict and then zooms in progressively
        &#34;&#34;&#34;
        if not self.is_infeasible():
            logger.info(&#39;Problem is feasible&#39;)
            return None

        return self._find_one_iis_and_zoom(&#39;quick_xplain&#39;)

    def find_set_of_distinct_iis_combined(self) -&gt; [[NamedBlock]]:
        &#34;&#34;&#34;Launches QuickXplain and Sufficient Assumption on two separate threads
        Returns the first result&#34;&#34;&#34;

        def thread_qx():
            logger.debug(&#39;Lauching QuickXplain&#39;)
            res = self.find_set_of_distinct_iis_qx()
            logger.debug(&#39;QuickXplain is done&#39;)
            return res

        def thread_sa():
            logger.debug(&#39;Launching Sufficient Assumption&#39;)
            res = self.find_set_of_distinct_iis_sa()
            logger.debug(&#39;Sufficient Assumption is done&#39;)
            return res

        class CustomProcess(Process):
            def __init__(self, tache, queue_de_retour):
                Process.__init__(self)
                self.tache = tache
                self.queue_de_retour = queue_de_retour

            def run(self):
                resultat = self.tache()
                self.queue_de_retour.put(resultat)

        queue_pour_le_resultat = Queue()
        liste_de_process = [CustomProcess(tache, queue_pour_le_resultat) for tache in [thread_qx, thread_sa]]

        for idx, process in enumerate(liste_de_process):
            process.start()

        resultat = queue_pour_le_resultat.get()

        for process in liste_de_process:
            process.terminate()

        return resultat

    def find_set_of_distinct_iis_qx(self) -&gt; [[NamedBlock]]:
        &#34;&#34;&#34;
        Returns a set of IIS that do not intersect each other, with QX method
        &#34;&#34;&#34;
        if not self.is_infeasible():
            return None

        mes_iis = []
        self.list_already_found_iis = []
        on_continue = True

        while on_continue:
            logger.info(&#39;Searching for a new IIS... &#39;)

            # On relache les contraintes des IIS déjà trouvés
            for iis in mes_iis:
                self.constraints_relaxation.relax_list_blocks(iis)

            # On vérifie qu&#39;on a encore au moins un conflit
            status = is_consistent(self.model, self.solver)

            if status:
                logger.info(&#39;No more IIS&#39;)
                on_continue = False
            else:
                nouvel_iis = self._find_one_iis_and_zoom(&#39;quick_xplain&#39;)
                if len(nouvel_iis) == 0:
                    on_continue = False
                else:
                    mes_iis.append(nouvel_iis)
                    self.list_already_found_iis.append(nouvel_iis)

        self.constraints_relaxation.inv_relax_all()
        return mes_iis

    def find_set_of_distinct_iis_sa(self) -&gt; [[NamedBlock]]:
        &#34;&#34;&#34;
        Returns a set of IIS that do not intersect each other, with SA method
        &#34;&#34;&#34;
        if not self.is_infeasible():
            return None

        mes_iis = []
        self.list_already_found_iis = []
        on_continue = True

        while on_continue:
            logger.info(&#39;Searching for a new IIS... &#39;)

            # On relache les contraintes des IIS déjà trouvés
            for iis in mes_iis:
                self.constraints_relaxation.relax_list_blocks(iis)

            # On vérifie qu&#39;on a encore au moins un conflit
            status = is_consistent(self.model, self.solver)

            if status:
                logger.info(&#39;No more IIS&#39;)
                on_continue = False
            else:
                mon_iis_uc = self._find_one_iis_and_zoom(&#39;sufficient_assumption&#39;)

                # On relache les contraintes des IIS déjà trouvés
                for iis in mes_iis:
                    self.constraints_relaxation.relax_list_blocks(iis)

                logger.debug(&#39;IIS found with sufficient assumption:&#39;)
                logger.debug(mon_iis_uc)

                if not mon_iis_uc:
                    mon_iis_uc = []

                self.constraints_relaxation.relax_all_real_constraints_but(mon_iis_uc)

                # Finds one IIS with sufficient assumption
                mes_blocks = mon_iis_uc + [b for b in self.dict_indexing.return_all_blocks_as_named() if not b.is_true_constraint()]
                mon_iis_complet = self._find_one_iis_and_zoom(&#39;quick_xplain&#39;, mes_blocks)

                logger.debug(&#39;Final IIS:&#39;)
                logger.debug(mon_iis_complet)

                if len(mon_iis_complet) == 0:
                    on_continue = False
                else:
                    mes_iis.append(mon_iis_complet)
                    self.list_already_found_iis.append(mon_iis_complet)

        self.constraints_relaxation.inv_relax_all()
        return mes_iis

    def split(self, C: List[NamedBlock], choice: int):
        # Attention à la méthode de découpage
        # S&#39;il n&#39;y a pas au moins un block dans chaque partie on va boucler à l&#39;infini
        &#34;&#34;&#34;
        Function that split the list C of constraint&#39;s blocks into two list of constraint&#39;s blocks
        Beware if implementing new splitting methods. If the method occasionally return one empty list, quick_xplain will enter an infinite loop
        :param C: (List[Block]) the list of constraint&#39;s blocks
        :param choice: (int) 1 to &#34;isolate&#34; the first block
                              2 to split &#34;by half&#34;
                              3 to split in two and balance the size of both parts
        :return: C_1, C_2: (List[Block]) two lists of constraint&#39;s blocks
        &#34;&#34;&#34;
        if choice == 1:
            return [C[0]], C[1:]
        if choice == 2:
            k = int(len(C) / 2)
            return C[:k], C[k:]
        if choice == 3:
            nb_blocs = len(C)
            if nb_blocs &lt; 2:
                return self.split(C, 2)

            mes_tailles = [b.size() for b in C]
            max_taille = sum(x for x in mes_tailles)

            &#34;&#34;&#34;On fait un mini problème d&#39;optimisation pour découper notre problème en deux parties égales&#34;&#34;&#34;
            model = cp_model.CpModel()
            solver2 = cp_model.CpSolver()
            solver2.parameters.max_time_in_seconds = 60
            affectations = {j: model.NewBoolVar(&#34;affect_{}&#34;.format(j)) for j in range(nb_blocs)}
            ecart_optimal = model.NewIntVar(0, max_taille, &#39;bloc_min&#39;)
            model.Add((2 * sum([affectations[j] * mes_tailles[j] for j in range(nb_blocs)]) - max_taille) &lt;= ecart_optimal)
            model.Add((max_taille - 2 * sum([affectations[j] * mes_tailles[j] for j in range(nb_blocs)])) &lt;= ecart_optimal)
            model.Minimize(ecart_optimal)
            res = solver2.Solve(model)

            if res == cp_model.OPTIMAL:
                bloc_1 = [C[j] for j in range(nb_blocs) if solver2.Value(affectations[j])]
                bloc_2 = [C[j] for j in range(nb_blocs) if not solver2.Value(affectations[j])]
                if len(bloc_2) == 0 or len(bloc_1) == 0:
                    return self.split(C, 2)
                return bloc_1, bloc_2
            else:
                return self.split(C, 2)

    def add_var_assumptions(self, all_blocks):
        &#34;&#34;&#34;
        Function that adds assumption variables
        &#34;&#34;&#34;
        for block in all_blocks:
            if block.is_true_constraint():
                nom_block = block.name()
                block_constraints = block.contenu()

                if block not in self.block_to_index_var_assumption:
                    b_var = self.model.NewBoolVar(nom_block)
                    b_var_ix = b_var.Index()
                    self.variables_ajoutees.append(b_var_ix)
                    self.index_var_assumption_to_block[b_var.Index()] = block
                    self.block_to_index_var_assumption[block] = b_var.Index()
                    self.model.Proto().assumptions.extend([b_var.Index()])

                for single_constraint in block_constraints:
                    if isinstance(single_constraint, UsualConstraint):
                        list_idx = single_constraint.list_idx()
                        for idx in list_idx:
                            if idx in self.list_idx_usual_constraints_with_assumptions:
                                logger.error(&#34;Trying to assign an assumption variable to a constraint which already has one&#34;)
                                raise IndexError

                            if idx in self.dict_indexing.get_list_usual_inamovible() or self.constraints_relaxation.is_relaxed_usual_constraint[single_constraint]:
                                continue

                            index_b_var = self.block_to_index_var_assumption[block]
                            self.model.Proto().constraints[idx].enforcement_literal.extend([index_b_var])
                            self.list_idx_usual_constraints_with_assumptions.append(idx)

    def inv_add_var_assumptions(self):
        &#34;&#34;&#34;Function that removes ALL assumption variables&#34;&#34;&#34;
        # On enlève les variables assumptions présentes devant les contraintes
        for idx_constraints in self.list_idx_usual_constraints_with_assumptions:
            self.model.Proto().constraints[idx_constraints].enforcement_literal.pop(0)

        self.model.Proto().assumptions[:] = []

        # On supprime les variables d&#39;assumption
        for ind in sorted(self.variables_ajoutees, reverse=True):
            self.model.Proto().variables.pop(ind)

        # On remet à jour notre &#34;mémoire&#34;
        self.index_var_assumption_to_block = dict()
        self.block_to_index_var_assumption = dict()
        self.list_idx_usual_constraints_with_assumptions = []
        self.variables_ajoutees = []

    def sufficient_assumption(self, all_blocks) -&gt; Union[List[NamedBlock], None]:
        &#34;&#34;&#34;
        Function that returns an iis with the Or-tools function : &#34;sufficient_assumptions_for_infeasibility&#34;
        :return: explanations: (List[Block]) a list of blocks corresponding to an IIS
        &#34;&#34;&#34;
        logger.info(&#34;Launching sufficient_assumption&#34;)
        self.add_var_assumptions(all_blocks)
        self.solver.parameters.num_search_workers = 1

        # On vérifie qu&#39;on a encore au moins un conflit
        status = is_consistent(self.model, self.solver)
        if status:
            self.inv_add_var_assumptions()
            return None
        else:
            assumptions = self.solver.ResponseProto().sufficient_assumptions_for_infeasibility
            explanations = set(self.index_var_assumption_to_block[index_b_var] for index_b_var in assumptions)
            self.inv_add_var_assumptions()
            return list(explanations)

    def quick_xplain(self, all_blocks) -&gt; Union[List[NamedBlock], None]:
        &#34;&#34;&#34;
        Function that implements the QuickXplain&#39;s algorithm
        :return: result: (List[Block]) a list of blocks corresponding to an IIS
        &#34;&#34;&#34;
        logger.info(&#34;Launching quick_xplain&#34;)

        # list_of_usual_constraints_already_released = copy(self.constraints_relaxation.is_relaxed_usual_constraint)
        # list_of_constant_constraints_already_released = copy(self.constraints_relaxation.is_relaxed_constant)

        list_of_usual_constraints_already_released = {x: True for x in self.constraints_relaxation.is_relaxed_usual_constraint if self.constraints_relaxation.is_relaxed_usual_constraint[x]}
        list_of_constant_constraints_already_released = {x: True for x in self.constraints_relaxation.is_relaxed_constant if self.constraints_relaxation.is_relaxed_constant[x]}

        logger.debug(&#39;Relaxed constraints :&#39;)
        logger.debug(list(list_of_usual_constraints_already_released.keys()) + [&#39;c_{}&#39;.format(cons) for cons in list_of_constant_constraints_already_released.keys()])

        def QX(delta_bool: bool, remaining_constraints: List[NamedBlock], i_rec=1) -&gt; List[NamedBlock]:
            &#34;&#34;&#34;
            Core of the recursive function of QuickXplain&#39;s algorithm
            :param delta_bool: (bool) True if a constraint has just been activated, or False
            :param remaining_constraints: (List[Block]) remaining constraints for IIS research
            :param i_rec: (int) an iterator
            :return: delta_1 + delta_2: (List[Block]) a list of blocks corresponding to an IIS
            &#34;&#34;&#34;
            logger.debug(&#34;\t&#34; * i_rec + &#34;QX: remaining constraints %s&#34; % remaining_constraints)

            if delta_bool and not is_consistent(self.model, self.solver):
                logger.debug(&#34;\t&#34; * i_rec + &#34;QX: infeasible&#34;)
                return []
            if len(remaining_constraints) == 1:
                logger.debug(&#34;\t&#34; * i_rec + &#34;QX: only one remaining constraint&#34;)
                return remaining_constraints

            logger.debug(&#34;\t&#34; * i_rec + &#34;QX: feasible&#34;)

            C_1, C_2 = self.split(remaining_constraints, choice=self.split_choice)
            logger.debug(&#34;\t&#34; * i_rec + &#34;C1: %s, C2: %s&#34; % (C_1, C_2))

            self.constraints_relaxation.inv_relax_list_blocks(C_1, list_usual_idx_not_to_release=list_of_usual_constraints_already_released,
                                                              list_constant_idx_not_to_release=list_of_constant_constraints_already_released)
            logger.debug(&#34;\t&#34;*i_rec + &#34;QX: Activate C1 : %s&#34; % C_1)
            logger.debug(&#34;\t&#34;*i_rec + &#34;QX: Searches in C_2 after having reactivated C_1 : %s&#34; % C_1)
            delta_2 = QX(delta_bool=True, remaining_constraints=C_2, i_rec=i_rec + 1)
            logger.debug(&#34;\t&#34;*i_rec + &#34;QX: Delta_2 : %s&#34; % delta_2)
            self.constraints_relaxation.relax_list_blocks(C_1)
            logger.debug(&#34;\t&#34;*i_rec + &#34;QX: Deactivate C1 : %s&#34; % C_1)

            if delta_2 and len(delta_2) &gt; 0:
                logger.debug(&#34;\t&#34;*i_rec + &#34;QX: Activate Delta_2 : %s&#34; % delta_2)
                self.constraints_relaxation.inv_relax_list_blocks(delta_2, list_usual_idx_not_to_release=list_of_usual_constraints_already_released,
                                                                  list_constant_idx_not_to_release=list_of_constant_constraints_already_released)
                logger.debug(&#34;\t&#34;*i_rec + &#34;QX: Searches in C_1 after having activated D2&#34;)
                delta_1 = QX(delta_bool=True, remaining_constraints=C_1, i_rec=i_rec + 1)
                logger.debug(&#34;\t&#34; * i_rec + &#34;QX: Delta_1 : %s&#34; % delta_1)

                logger.debug(&#34;\t&#34;*i_rec + &#34;QX: Deactivate Delta_2 : %s&#34; % delta_2)
                self.constraints_relaxation.relax_list_blocks(delta_2)
            else:
                logger.debug(&#34;\t&#34;*i_rec + &#34;QX: Searches in C_1&#34;)
                delta_1 = QX(delta_bool=False, remaining_constraints=C_1, i_rec=i_rec + 1)
                logger.debug(&#34;\t&#34; * i_rec + &#34;QX: Delta_1 : %s&#34; % delta_1)

            logger.debug(&#34;\t&#34;*i_rec + &#34;QX: Delta_1 + Delta_2 : %s&#34; % (delta_1 + delta_2))

            return delta_1 + delta_2

        if is_consistent(self.model, self.solver):
            logger.error(&#39;Quick Xplain was called but model is feasible&#39;)
            return None

        # all_blocks = [block for block in self.dict_indexing.splits_on_granularity()]

        logger.debug(&#39;List of blocks:&#39;)
        logger.debug(all_blocks)

        if len(all_blocks) == 0:
            return []

        logger.debug(&#34;QX: Deactivates all constraints: %s&#34; % all_blocks)
        self.constraints_relaxation.relax_list_blocks(all_blocks)
        result = QX(delta_bool=True, remaining_constraints=all_blocks)
        logger.debug(&#34;QX: Reactivates all constraints: %s&#34; % all_blocks)
        self.constraints_relaxation.inv_relax_list_blocks(all_blocks,
                                                          list_usual_idx_not_to_release=list_of_usual_constraints_already_released,
                                                          list_constant_idx_not_to_release=list_of_constant_constraints_already_released)
        return result

    def find_iis_single_call(self, method: str, all_blocks) -&gt; Union[List[NamedBlock], None]:
        &#34;&#34;&#34;
        Function that searches for an IIS according to the chosen method (quick_xplain or sufficient_assumption)
        :return: result: (List[NamedBlock]) a list of blocks corresponding to an IIS
        &#34;&#34;&#34;
        result = None
        if method == &#34;quick_xplain&#34;:
            result = self.quick_xplain(all_blocks)
            logger.info(&#34;End of quick_xplain&#34;)
        elif method == &#34;sufficient_assumption&#34;:
            result = self.sufficient_assumption(all_blocks)
            logger.info(&#34;End of sufficient_assumption&#34;)

        return sorted(result)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="ortools_utils.explainability.negative_explanations.NegativeExplanation"><code class="flex name class">
<span>class <span class="ident">NegativeExplanation</span></span>
<span>(</span><span>model, split_choice=3, nb_iis_granularite=1)</span>
</code></dt>
<dd>
<div class="desc"><p>Class for generating the explanation of an unsolvable model.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class NegativeExplanation:
    &#34;&#34;&#34;
    Class for generating the explanation of an unsolvable model.
    &#34;&#34;&#34;

    def __init__(
            self,
            model,
            split_choice=3,  # Argument explaining how we split the set of constraints in two
            nb_iis_granularite=1
    ):
        self.model = model
        self.dict_indexing = model.dict_indexing()
        self.nb_iis_granularite = nb_iis_granularite

        self.constraints_relaxation = ConstraintsRelaxation(model)
        self.solver = cp_model.CpSolver()

        self.index_var_assumption_to_block: Dict[int, NamedBlock] = dict()
        self.block_to_index_var_assumption: Dict[NamedBlock, int] = dict()
        self.list_idx_usual_constraints_with_assumptions = []
        self.list_idx_constant_constraints_with_assumptions = []
        self.variables_ajoutees = []

        self.list_already_found_iis = []

        self.split_choice = split_choice

    def is_infeasible(self) -&gt; bool:
        &#34;&#34;&#34;Before searching for IIS, checks once and for all that the model is not feasible&#34;&#34;&#34;
        self.model.Proto().ClearField(&#34;objective&#34;)
        return not is_consistent(self.model, self.solver)

    def find_one_iis_combined(self) -&gt; [NamedBlock]:
        &#34;&#34;&#34;Launches QuickXplain and Sufficient Assumption on two separate threads
        Returns the first result&#34;&#34;&#34;

        def thread_qx():
            logger.debug(&#39;Launching QuickXplain&#39;)
            res = self.find_one_iis_auto_zoom_quick_xplain()
            logger.debug(&#39;QuickXplain is done&#39;)
            return res

        def thread_sa():
            logger.debug(&#39;Launching Sufficient Assumption&#39;)
            res = self.find_one_iis_sufficient_assumption()
            logger.debug(&#39;Sufficient Assumption is done&#39;)
            return res

        class CustomProcess(Process):
            def __init__(self, tache, queue_de_retour):
                Process.__init__(self)
                self.tache = tache
                self.queue_de_retour = queue_de_retour

            def run(self):
                resultat = self.tache()
                self.queue_de_retour.put(resultat)

        queue_pour_le_resultat = Queue()
        liste_de_process = [CustomProcess(tache, queue_pour_le_resultat) for tache in [thread_qx, thread_sa]]

        for idx, process in enumerate(liste_de_process):
            process.start()

        resultat = queue_pour_le_resultat.get()

        for process in liste_de_process:
            process.terminate()

        return resultat

    def find_one_iis_sufficient_assumption(self) -&gt; [NamedBlock]:
        &#34;&#34;&#34;
        Finds one IIS with the Sufficient Assumption way
        Also uses a little Quick Xplain because SA does not handle constant constraints
        &#34;&#34;&#34;
        if not self.is_infeasible():
            logger.info(&#39;Problem is solvable&#39;)
            return None

        mon_iis_uc = self._find_one_iis_and_zoom(&#39;sufficient_assumption&#39;)
        if not mon_iis_uc:
            mon_iis_uc = []

        logger.info(&#39;IIS found with sufficient assumption :&#39;)
        logger.info(mon_iis_uc)
        logger.info(&#39;Reducing the IIS with quick xplain... &#39;)

        self.constraints_relaxation.relax_all_real_constraints_but(mon_iis_uc)

        # Finds one IIS with sufficient assumption
        mes_blocks = mon_iis_uc + [b for b in self.dict_indexing.return_all_blocks_as_named() if not b.is_true_constraint()]
        mon_iis_complet = self._find_one_iis_and_zoom(&#39;quick_xplain&#39;, mes_blocks)

        logger.info(&#39;Final IIS:&#39;)
        logger.info(mon_iis_complet)

        return mon_iis_complet

    def _find_one_iis_and_zoom(self, method: str, all_blocks=None) -&gt; [NamedBlock]:
        &#34;&#34;&#34;
        Finds one IIS on self.model (some constraints may be released)
        Zooms automatically to return an IIS with the most appropriate granularity
        At the end of this function, relaxed blocks are exactly the same as in the beginning
        &#34;&#34;&#34;
        if not all_blocks:
            all_blocks = self.dict_indexing.return_all_blocks_as_named()

        # Granularité initiale
        current_iis = self.find_iis_single_call(method, all_blocks)  # Liste de NamedBlock
        if len(current_iis) == 0:
            logger.info(&#39;There is a problem within the background blocks&#39;)
            return []

        # On relache une fois pour toutes ce qui n&#39;est pas dans l&#39;IIS
        self.constraints_relaxation.relax_all_but(current_iis, method)

        logger.info(&#39;Large IIS: &#39;)
        logger.info(current_iis)

        while True:
            longueur_iis = len(current_iis)
            nouv_iis = None
            new_blocks = None
            for nb in current_iis:
                while nb.can_be_split() and not new_blocks:
                    list_nb = nb.split_on_next_dimension()
                    new_blocks = list_nb + [b for b in current_iis if b != nb]
                    logger.debug(&#39;New blocks : {}&#39;.format(new_blocks))
                    nouv_iis = self.find_iis_single_call(method, new_blocks)
                    logger.debug(&#39;New-scale IIS : {}&#39;.format(nouv_iis))
                    if len(nouv_iis) &gt; longueur_iis + self.nb_iis_granularite - 1:
                        logger.debug(&#39;This dimension is not relevant&#39;)
                        nb.remove_dim_to_split()
                        nouv_iis = None
                        new_blocks = None
            if not nouv_iis:
                break
            else:
                current_iis = nouv_iis
                self.constraints_relaxation.relax_all_but(current_iis, method)
                logger.info(&#39;Current IIS: &#39;)
                logger.info(current_iis)

        logger.info(&#39;Final IIS:&#39;)
        logger.info(current_iis)
        self.constraints_relaxation.inv_relax_all()
        return current_iis

    def find_one_iis_auto_zoom_quick_xplain(self) -&gt; [NamedBlock]:
        &#34;&#34;&#34;
        Finds one IIS by zooming automatically with QX method
        Starts by finding MacroBlocks that are in conflict and then zooms in progressively
        &#34;&#34;&#34;
        if not self.is_infeasible():
            logger.info(&#39;Problem is feasible&#39;)
            return None

        return self._find_one_iis_and_zoom(&#39;quick_xplain&#39;)

    def find_set_of_distinct_iis_combined(self) -&gt; [[NamedBlock]]:
        &#34;&#34;&#34;Launches QuickXplain and Sufficient Assumption on two separate threads
        Returns the first result&#34;&#34;&#34;

        def thread_qx():
            logger.debug(&#39;Lauching QuickXplain&#39;)
            res = self.find_set_of_distinct_iis_qx()
            logger.debug(&#39;QuickXplain is done&#39;)
            return res

        def thread_sa():
            logger.debug(&#39;Launching Sufficient Assumption&#39;)
            res = self.find_set_of_distinct_iis_sa()
            logger.debug(&#39;Sufficient Assumption is done&#39;)
            return res

        class CustomProcess(Process):
            def __init__(self, tache, queue_de_retour):
                Process.__init__(self)
                self.tache = tache
                self.queue_de_retour = queue_de_retour

            def run(self):
                resultat = self.tache()
                self.queue_de_retour.put(resultat)

        queue_pour_le_resultat = Queue()
        liste_de_process = [CustomProcess(tache, queue_pour_le_resultat) for tache in [thread_qx, thread_sa]]

        for idx, process in enumerate(liste_de_process):
            process.start()

        resultat = queue_pour_le_resultat.get()

        for process in liste_de_process:
            process.terminate()

        return resultat

    def find_set_of_distinct_iis_qx(self) -&gt; [[NamedBlock]]:
        &#34;&#34;&#34;
        Returns a set of IIS that do not intersect each other, with QX method
        &#34;&#34;&#34;
        if not self.is_infeasible():
            return None

        mes_iis = []
        self.list_already_found_iis = []
        on_continue = True

        while on_continue:
            logger.info(&#39;Searching for a new IIS... &#39;)

            # On relache les contraintes des IIS déjà trouvés
            for iis in mes_iis:
                self.constraints_relaxation.relax_list_blocks(iis)

            # On vérifie qu&#39;on a encore au moins un conflit
            status = is_consistent(self.model, self.solver)

            if status:
                logger.info(&#39;No more IIS&#39;)
                on_continue = False
            else:
                nouvel_iis = self._find_one_iis_and_zoom(&#39;quick_xplain&#39;)
                if len(nouvel_iis) == 0:
                    on_continue = False
                else:
                    mes_iis.append(nouvel_iis)
                    self.list_already_found_iis.append(nouvel_iis)

        self.constraints_relaxation.inv_relax_all()
        return mes_iis

    def find_set_of_distinct_iis_sa(self) -&gt; [[NamedBlock]]:
        &#34;&#34;&#34;
        Returns a set of IIS that do not intersect each other, with SA method
        &#34;&#34;&#34;
        if not self.is_infeasible():
            return None

        mes_iis = []
        self.list_already_found_iis = []
        on_continue = True

        while on_continue:
            logger.info(&#39;Searching for a new IIS... &#39;)

            # On relache les contraintes des IIS déjà trouvés
            for iis in mes_iis:
                self.constraints_relaxation.relax_list_blocks(iis)

            # On vérifie qu&#39;on a encore au moins un conflit
            status = is_consistent(self.model, self.solver)

            if status:
                logger.info(&#39;No more IIS&#39;)
                on_continue = False
            else:
                mon_iis_uc = self._find_one_iis_and_zoom(&#39;sufficient_assumption&#39;)

                # On relache les contraintes des IIS déjà trouvés
                for iis in mes_iis:
                    self.constraints_relaxation.relax_list_blocks(iis)

                logger.debug(&#39;IIS found with sufficient assumption:&#39;)
                logger.debug(mon_iis_uc)

                if not mon_iis_uc:
                    mon_iis_uc = []

                self.constraints_relaxation.relax_all_real_constraints_but(mon_iis_uc)

                # Finds one IIS with sufficient assumption
                mes_blocks = mon_iis_uc + [b for b in self.dict_indexing.return_all_blocks_as_named() if not b.is_true_constraint()]
                mon_iis_complet = self._find_one_iis_and_zoom(&#39;quick_xplain&#39;, mes_blocks)

                logger.debug(&#39;Final IIS:&#39;)
                logger.debug(mon_iis_complet)

                if len(mon_iis_complet) == 0:
                    on_continue = False
                else:
                    mes_iis.append(mon_iis_complet)
                    self.list_already_found_iis.append(mon_iis_complet)

        self.constraints_relaxation.inv_relax_all()
        return mes_iis

    def split(self, C: List[NamedBlock], choice: int):
        # Attention à la méthode de découpage
        # S&#39;il n&#39;y a pas au moins un block dans chaque partie on va boucler à l&#39;infini
        &#34;&#34;&#34;
        Function that split the list C of constraint&#39;s blocks into two list of constraint&#39;s blocks
        Beware if implementing new splitting methods. If the method occasionally return one empty list, quick_xplain will enter an infinite loop
        :param C: (List[Block]) the list of constraint&#39;s blocks
        :param choice: (int) 1 to &#34;isolate&#34; the first block
                              2 to split &#34;by half&#34;
                              3 to split in two and balance the size of both parts
        :return: C_1, C_2: (List[Block]) two lists of constraint&#39;s blocks
        &#34;&#34;&#34;
        if choice == 1:
            return [C[0]], C[1:]
        if choice == 2:
            k = int(len(C) / 2)
            return C[:k], C[k:]
        if choice == 3:
            nb_blocs = len(C)
            if nb_blocs &lt; 2:
                return self.split(C, 2)

            mes_tailles = [b.size() for b in C]
            max_taille = sum(x for x in mes_tailles)

            &#34;&#34;&#34;On fait un mini problème d&#39;optimisation pour découper notre problème en deux parties égales&#34;&#34;&#34;
            model = cp_model.CpModel()
            solver2 = cp_model.CpSolver()
            solver2.parameters.max_time_in_seconds = 60
            affectations = {j: model.NewBoolVar(&#34;affect_{}&#34;.format(j)) for j in range(nb_blocs)}
            ecart_optimal = model.NewIntVar(0, max_taille, &#39;bloc_min&#39;)
            model.Add((2 * sum([affectations[j] * mes_tailles[j] for j in range(nb_blocs)]) - max_taille) &lt;= ecart_optimal)
            model.Add((max_taille - 2 * sum([affectations[j] * mes_tailles[j] for j in range(nb_blocs)])) &lt;= ecart_optimal)
            model.Minimize(ecart_optimal)
            res = solver2.Solve(model)

            if res == cp_model.OPTIMAL:
                bloc_1 = [C[j] for j in range(nb_blocs) if solver2.Value(affectations[j])]
                bloc_2 = [C[j] for j in range(nb_blocs) if not solver2.Value(affectations[j])]
                if len(bloc_2) == 0 or len(bloc_1) == 0:
                    return self.split(C, 2)
                return bloc_1, bloc_2
            else:
                return self.split(C, 2)

    def add_var_assumptions(self, all_blocks):
        &#34;&#34;&#34;
        Function that adds assumption variables
        &#34;&#34;&#34;
        for block in all_blocks:
            if block.is_true_constraint():
                nom_block = block.name()
                block_constraints = block.contenu()

                if block not in self.block_to_index_var_assumption:
                    b_var = self.model.NewBoolVar(nom_block)
                    b_var_ix = b_var.Index()
                    self.variables_ajoutees.append(b_var_ix)
                    self.index_var_assumption_to_block[b_var.Index()] = block
                    self.block_to_index_var_assumption[block] = b_var.Index()
                    self.model.Proto().assumptions.extend([b_var.Index()])

                for single_constraint in block_constraints:
                    if isinstance(single_constraint, UsualConstraint):
                        list_idx = single_constraint.list_idx()
                        for idx in list_idx:
                            if idx in self.list_idx_usual_constraints_with_assumptions:
                                logger.error(&#34;Trying to assign an assumption variable to a constraint which already has one&#34;)
                                raise IndexError

                            if idx in self.dict_indexing.get_list_usual_inamovible() or self.constraints_relaxation.is_relaxed_usual_constraint[single_constraint]:
                                continue

                            index_b_var = self.block_to_index_var_assumption[block]
                            self.model.Proto().constraints[idx].enforcement_literal.extend([index_b_var])
                            self.list_idx_usual_constraints_with_assumptions.append(idx)

    def inv_add_var_assumptions(self):
        &#34;&#34;&#34;Function that removes ALL assumption variables&#34;&#34;&#34;
        # On enlève les variables assumptions présentes devant les contraintes
        for idx_constraints in self.list_idx_usual_constraints_with_assumptions:
            self.model.Proto().constraints[idx_constraints].enforcement_literal.pop(0)

        self.model.Proto().assumptions[:] = []

        # On supprime les variables d&#39;assumption
        for ind in sorted(self.variables_ajoutees, reverse=True):
            self.model.Proto().variables.pop(ind)

        # On remet à jour notre &#34;mémoire&#34;
        self.index_var_assumption_to_block = dict()
        self.block_to_index_var_assumption = dict()
        self.list_idx_usual_constraints_with_assumptions = []
        self.variables_ajoutees = []

    def sufficient_assumption(self, all_blocks) -&gt; Union[List[NamedBlock], None]:
        &#34;&#34;&#34;
        Function that returns an iis with the Or-tools function : &#34;sufficient_assumptions_for_infeasibility&#34;
        :return: explanations: (List[Block]) a list of blocks corresponding to an IIS
        &#34;&#34;&#34;
        logger.info(&#34;Launching sufficient_assumption&#34;)
        self.add_var_assumptions(all_blocks)
        self.solver.parameters.num_search_workers = 1

        # On vérifie qu&#39;on a encore au moins un conflit
        status = is_consistent(self.model, self.solver)
        if status:
            self.inv_add_var_assumptions()
            return None
        else:
            assumptions = self.solver.ResponseProto().sufficient_assumptions_for_infeasibility
            explanations = set(self.index_var_assumption_to_block[index_b_var] for index_b_var in assumptions)
            self.inv_add_var_assumptions()
            return list(explanations)

    def quick_xplain(self, all_blocks) -&gt; Union[List[NamedBlock], None]:
        &#34;&#34;&#34;
        Function that implements the QuickXplain&#39;s algorithm
        :return: result: (List[Block]) a list of blocks corresponding to an IIS
        &#34;&#34;&#34;
        logger.info(&#34;Launching quick_xplain&#34;)

        # list_of_usual_constraints_already_released = copy(self.constraints_relaxation.is_relaxed_usual_constraint)
        # list_of_constant_constraints_already_released = copy(self.constraints_relaxation.is_relaxed_constant)

        list_of_usual_constraints_already_released = {x: True for x in self.constraints_relaxation.is_relaxed_usual_constraint if self.constraints_relaxation.is_relaxed_usual_constraint[x]}
        list_of_constant_constraints_already_released = {x: True for x in self.constraints_relaxation.is_relaxed_constant if self.constraints_relaxation.is_relaxed_constant[x]}

        logger.debug(&#39;Relaxed constraints :&#39;)
        logger.debug(list(list_of_usual_constraints_already_released.keys()) + [&#39;c_{}&#39;.format(cons) for cons in list_of_constant_constraints_already_released.keys()])

        def QX(delta_bool: bool, remaining_constraints: List[NamedBlock], i_rec=1) -&gt; List[NamedBlock]:
            &#34;&#34;&#34;
            Core of the recursive function of QuickXplain&#39;s algorithm
            :param delta_bool: (bool) True if a constraint has just been activated, or False
            :param remaining_constraints: (List[Block]) remaining constraints for IIS research
            :param i_rec: (int) an iterator
            :return: delta_1 + delta_2: (List[Block]) a list of blocks corresponding to an IIS
            &#34;&#34;&#34;
            logger.debug(&#34;\t&#34; * i_rec + &#34;QX: remaining constraints %s&#34; % remaining_constraints)

            if delta_bool and not is_consistent(self.model, self.solver):
                logger.debug(&#34;\t&#34; * i_rec + &#34;QX: infeasible&#34;)
                return []
            if len(remaining_constraints) == 1:
                logger.debug(&#34;\t&#34; * i_rec + &#34;QX: only one remaining constraint&#34;)
                return remaining_constraints

            logger.debug(&#34;\t&#34; * i_rec + &#34;QX: feasible&#34;)

            C_1, C_2 = self.split(remaining_constraints, choice=self.split_choice)
            logger.debug(&#34;\t&#34; * i_rec + &#34;C1: %s, C2: %s&#34; % (C_1, C_2))

            self.constraints_relaxation.inv_relax_list_blocks(C_1, list_usual_idx_not_to_release=list_of_usual_constraints_already_released,
                                                              list_constant_idx_not_to_release=list_of_constant_constraints_already_released)
            logger.debug(&#34;\t&#34;*i_rec + &#34;QX: Activate C1 : %s&#34; % C_1)
            logger.debug(&#34;\t&#34;*i_rec + &#34;QX: Searches in C_2 after having reactivated C_1 : %s&#34; % C_1)
            delta_2 = QX(delta_bool=True, remaining_constraints=C_2, i_rec=i_rec + 1)
            logger.debug(&#34;\t&#34;*i_rec + &#34;QX: Delta_2 : %s&#34; % delta_2)
            self.constraints_relaxation.relax_list_blocks(C_1)
            logger.debug(&#34;\t&#34;*i_rec + &#34;QX: Deactivate C1 : %s&#34; % C_1)

            if delta_2 and len(delta_2) &gt; 0:
                logger.debug(&#34;\t&#34;*i_rec + &#34;QX: Activate Delta_2 : %s&#34; % delta_2)
                self.constraints_relaxation.inv_relax_list_blocks(delta_2, list_usual_idx_not_to_release=list_of_usual_constraints_already_released,
                                                                  list_constant_idx_not_to_release=list_of_constant_constraints_already_released)
                logger.debug(&#34;\t&#34;*i_rec + &#34;QX: Searches in C_1 after having activated D2&#34;)
                delta_1 = QX(delta_bool=True, remaining_constraints=C_1, i_rec=i_rec + 1)
                logger.debug(&#34;\t&#34; * i_rec + &#34;QX: Delta_1 : %s&#34; % delta_1)

                logger.debug(&#34;\t&#34;*i_rec + &#34;QX: Deactivate Delta_2 : %s&#34; % delta_2)
                self.constraints_relaxation.relax_list_blocks(delta_2)
            else:
                logger.debug(&#34;\t&#34;*i_rec + &#34;QX: Searches in C_1&#34;)
                delta_1 = QX(delta_bool=False, remaining_constraints=C_1, i_rec=i_rec + 1)
                logger.debug(&#34;\t&#34; * i_rec + &#34;QX: Delta_1 : %s&#34; % delta_1)

            logger.debug(&#34;\t&#34;*i_rec + &#34;QX: Delta_1 + Delta_2 : %s&#34; % (delta_1 + delta_2))

            return delta_1 + delta_2

        if is_consistent(self.model, self.solver):
            logger.error(&#39;Quick Xplain was called but model is feasible&#39;)
            return None

        # all_blocks = [block for block in self.dict_indexing.splits_on_granularity()]

        logger.debug(&#39;List of blocks:&#39;)
        logger.debug(all_blocks)

        if len(all_blocks) == 0:
            return []

        logger.debug(&#34;QX: Deactivates all constraints: %s&#34; % all_blocks)
        self.constraints_relaxation.relax_list_blocks(all_blocks)
        result = QX(delta_bool=True, remaining_constraints=all_blocks)
        logger.debug(&#34;QX: Reactivates all constraints: %s&#34; % all_blocks)
        self.constraints_relaxation.inv_relax_list_blocks(all_blocks,
                                                          list_usual_idx_not_to_release=list_of_usual_constraints_already_released,
                                                          list_constant_idx_not_to_release=list_of_constant_constraints_already_released)
        return result

    def find_iis_single_call(self, method: str, all_blocks) -&gt; Union[List[NamedBlock], None]:
        &#34;&#34;&#34;
        Function that searches for an IIS according to the chosen method (quick_xplain or sufficient_assumption)
        :return: result: (List[NamedBlock]) a list of blocks corresponding to an IIS
        &#34;&#34;&#34;
        result = None
        if method == &#34;quick_xplain&#34;:
            result = self.quick_xplain(all_blocks)
            logger.info(&#34;End of quick_xplain&#34;)
        elif method == &#34;sufficient_assumption&#34;:
            result = self.sufficient_assumption(all_blocks)
            logger.info(&#34;End of sufficient_assumption&#34;)

        return sorted(result)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="ortools_utils.explainability.negative_explanations.NegativeExplanation.add_var_assumptions"><code class="name flex">
<span>def <span class="ident">add_var_assumptions</span></span>(<span>self, all_blocks)</span>
</code></dt>
<dd>
<div class="desc"><p>Function that adds assumption variables</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_var_assumptions(self, all_blocks):
    &#34;&#34;&#34;
    Function that adds assumption variables
    &#34;&#34;&#34;
    for block in all_blocks:
        if block.is_true_constraint():
            nom_block = block.name()
            block_constraints = block.contenu()

            if block not in self.block_to_index_var_assumption:
                b_var = self.model.NewBoolVar(nom_block)
                b_var_ix = b_var.Index()
                self.variables_ajoutees.append(b_var_ix)
                self.index_var_assumption_to_block[b_var.Index()] = block
                self.block_to_index_var_assumption[block] = b_var.Index()
                self.model.Proto().assumptions.extend([b_var.Index()])

            for single_constraint in block_constraints:
                if isinstance(single_constraint, UsualConstraint):
                    list_idx = single_constraint.list_idx()
                    for idx in list_idx:
                        if idx in self.list_idx_usual_constraints_with_assumptions:
                            logger.error(&#34;Trying to assign an assumption variable to a constraint which already has one&#34;)
                            raise IndexError

                        if idx in self.dict_indexing.get_list_usual_inamovible() or self.constraints_relaxation.is_relaxed_usual_constraint[single_constraint]:
                            continue

                        index_b_var = self.block_to_index_var_assumption[block]
                        self.model.Proto().constraints[idx].enforcement_literal.extend([index_b_var])
                        self.list_idx_usual_constraints_with_assumptions.append(idx)</code></pre>
</details>
</dd>
<dt id="ortools_utils.explainability.negative_explanations.NegativeExplanation.find_iis_single_call"><code class="name flex">
<span>def <span class="ident">find_iis_single_call</span></span>(<span>self, method: str, all_blocks) ‑> Optional[List[<a title="ortools_utils.model_indexation.constraints.NamedBlock" href="../model_indexation/constraints.html#ortools_utils.model_indexation.constraints.NamedBlock">NamedBlock</a>]]</span>
</code></dt>
<dd>
<div class="desc"><p>Function that searches for an IIS according to the chosen method (quick_xplain or sufficient_assumption)
:return: result: (List[NamedBlock]) a list of blocks corresponding to an IIS</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def find_iis_single_call(self, method: str, all_blocks) -&gt; Union[List[NamedBlock], None]:
    &#34;&#34;&#34;
    Function that searches for an IIS according to the chosen method (quick_xplain or sufficient_assumption)
    :return: result: (List[NamedBlock]) a list of blocks corresponding to an IIS
    &#34;&#34;&#34;
    result = None
    if method == &#34;quick_xplain&#34;:
        result = self.quick_xplain(all_blocks)
        logger.info(&#34;End of quick_xplain&#34;)
    elif method == &#34;sufficient_assumption&#34;:
        result = self.sufficient_assumption(all_blocks)
        logger.info(&#34;End of sufficient_assumption&#34;)

    return sorted(result)</code></pre>
</details>
</dd>
<dt id="ortools_utils.explainability.negative_explanations.NegativeExplanation.find_one_iis_auto_zoom_quick_xplain"><code class="name flex">
<span>def <span class="ident">find_one_iis_auto_zoom_quick_xplain</span></span>(<span>self) ‑> [<class '<a title="ortools_utils.model_indexation.constraints.NamedBlock" href="../model_indexation/constraints.html#ortools_utils.model_indexation.constraints.NamedBlock">NamedBlock</a>'>]</span>
</code></dt>
<dd>
<div class="desc"><p>Finds one IIS by zooming automatically with QX method
Starts by finding MacroBlocks that are in conflict and then zooms in progressively</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def find_one_iis_auto_zoom_quick_xplain(self) -&gt; [NamedBlock]:
    &#34;&#34;&#34;
    Finds one IIS by zooming automatically with QX method
    Starts by finding MacroBlocks that are in conflict and then zooms in progressively
    &#34;&#34;&#34;
    if not self.is_infeasible():
        logger.info(&#39;Problem is feasible&#39;)
        return None

    return self._find_one_iis_and_zoom(&#39;quick_xplain&#39;)</code></pre>
</details>
</dd>
<dt id="ortools_utils.explainability.negative_explanations.NegativeExplanation.find_one_iis_combined"><code class="name flex">
<span>def <span class="ident">find_one_iis_combined</span></span>(<span>self) ‑> [<class '<a title="ortools_utils.model_indexation.constraints.NamedBlock" href="../model_indexation/constraints.html#ortools_utils.model_indexation.constraints.NamedBlock">NamedBlock</a>'>]</span>
</code></dt>
<dd>
<div class="desc"><p>Launches QuickXplain and Sufficient Assumption on two separate threads
Returns the first result</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def find_one_iis_combined(self) -&gt; [NamedBlock]:
    &#34;&#34;&#34;Launches QuickXplain and Sufficient Assumption on two separate threads
    Returns the first result&#34;&#34;&#34;

    def thread_qx():
        logger.debug(&#39;Launching QuickXplain&#39;)
        res = self.find_one_iis_auto_zoom_quick_xplain()
        logger.debug(&#39;QuickXplain is done&#39;)
        return res

    def thread_sa():
        logger.debug(&#39;Launching Sufficient Assumption&#39;)
        res = self.find_one_iis_sufficient_assumption()
        logger.debug(&#39;Sufficient Assumption is done&#39;)
        return res

    class CustomProcess(Process):
        def __init__(self, tache, queue_de_retour):
            Process.__init__(self)
            self.tache = tache
            self.queue_de_retour = queue_de_retour

        def run(self):
            resultat = self.tache()
            self.queue_de_retour.put(resultat)

    queue_pour_le_resultat = Queue()
    liste_de_process = [CustomProcess(tache, queue_pour_le_resultat) for tache in [thread_qx, thread_sa]]

    for idx, process in enumerate(liste_de_process):
        process.start()

    resultat = queue_pour_le_resultat.get()

    for process in liste_de_process:
        process.terminate()

    return resultat</code></pre>
</details>
</dd>
<dt id="ortools_utils.explainability.negative_explanations.NegativeExplanation.find_one_iis_sufficient_assumption"><code class="name flex">
<span>def <span class="ident">find_one_iis_sufficient_assumption</span></span>(<span>self) ‑> [<class '<a title="ortools_utils.model_indexation.constraints.NamedBlock" href="../model_indexation/constraints.html#ortools_utils.model_indexation.constraints.NamedBlock">NamedBlock</a>'>]</span>
</code></dt>
<dd>
<div class="desc"><p>Finds one IIS with the Sufficient Assumption way
Also uses a little Quick Xplain because SA does not handle constant constraints</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def find_one_iis_sufficient_assumption(self) -&gt; [NamedBlock]:
    &#34;&#34;&#34;
    Finds one IIS with the Sufficient Assumption way
    Also uses a little Quick Xplain because SA does not handle constant constraints
    &#34;&#34;&#34;
    if not self.is_infeasible():
        logger.info(&#39;Problem is solvable&#39;)
        return None

    mon_iis_uc = self._find_one_iis_and_zoom(&#39;sufficient_assumption&#39;)
    if not mon_iis_uc:
        mon_iis_uc = []

    logger.info(&#39;IIS found with sufficient assumption :&#39;)
    logger.info(mon_iis_uc)
    logger.info(&#39;Reducing the IIS with quick xplain... &#39;)

    self.constraints_relaxation.relax_all_real_constraints_but(mon_iis_uc)

    # Finds one IIS with sufficient assumption
    mes_blocks = mon_iis_uc + [b for b in self.dict_indexing.return_all_blocks_as_named() if not b.is_true_constraint()]
    mon_iis_complet = self._find_one_iis_and_zoom(&#39;quick_xplain&#39;, mes_blocks)

    logger.info(&#39;Final IIS:&#39;)
    logger.info(mon_iis_complet)

    return mon_iis_complet</code></pre>
</details>
</dd>
<dt id="ortools_utils.explainability.negative_explanations.NegativeExplanation.find_set_of_distinct_iis_combined"><code class="name flex">
<span>def <span class="ident">find_set_of_distinct_iis_combined</span></span>(<span>self) ‑> [[<class '<a title="ortools_utils.model_indexation.constraints.NamedBlock" href="../model_indexation/constraints.html#ortools_utils.model_indexation.constraints.NamedBlock">NamedBlock</a>'>]]</span>
</code></dt>
<dd>
<div class="desc"><p>Launches QuickXplain and Sufficient Assumption on two separate threads
Returns the first result</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def find_set_of_distinct_iis_combined(self) -&gt; [[NamedBlock]]:
    &#34;&#34;&#34;Launches QuickXplain and Sufficient Assumption on two separate threads
    Returns the first result&#34;&#34;&#34;

    def thread_qx():
        logger.debug(&#39;Lauching QuickXplain&#39;)
        res = self.find_set_of_distinct_iis_qx()
        logger.debug(&#39;QuickXplain is done&#39;)
        return res

    def thread_sa():
        logger.debug(&#39;Launching Sufficient Assumption&#39;)
        res = self.find_set_of_distinct_iis_sa()
        logger.debug(&#39;Sufficient Assumption is done&#39;)
        return res

    class CustomProcess(Process):
        def __init__(self, tache, queue_de_retour):
            Process.__init__(self)
            self.tache = tache
            self.queue_de_retour = queue_de_retour

        def run(self):
            resultat = self.tache()
            self.queue_de_retour.put(resultat)

    queue_pour_le_resultat = Queue()
    liste_de_process = [CustomProcess(tache, queue_pour_le_resultat) for tache in [thread_qx, thread_sa]]

    for idx, process in enumerate(liste_de_process):
        process.start()

    resultat = queue_pour_le_resultat.get()

    for process in liste_de_process:
        process.terminate()

    return resultat</code></pre>
</details>
</dd>
<dt id="ortools_utils.explainability.negative_explanations.NegativeExplanation.find_set_of_distinct_iis_qx"><code class="name flex">
<span>def <span class="ident">find_set_of_distinct_iis_qx</span></span>(<span>self) ‑> [[<class '<a title="ortools_utils.model_indexation.constraints.NamedBlock" href="../model_indexation/constraints.html#ortools_utils.model_indexation.constraints.NamedBlock">NamedBlock</a>'>]]</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a set of IIS that do not intersect each other, with QX method</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def find_set_of_distinct_iis_qx(self) -&gt; [[NamedBlock]]:
    &#34;&#34;&#34;
    Returns a set of IIS that do not intersect each other, with QX method
    &#34;&#34;&#34;
    if not self.is_infeasible():
        return None

    mes_iis = []
    self.list_already_found_iis = []
    on_continue = True

    while on_continue:
        logger.info(&#39;Searching for a new IIS... &#39;)

        # On relache les contraintes des IIS déjà trouvés
        for iis in mes_iis:
            self.constraints_relaxation.relax_list_blocks(iis)

        # On vérifie qu&#39;on a encore au moins un conflit
        status = is_consistent(self.model, self.solver)

        if status:
            logger.info(&#39;No more IIS&#39;)
            on_continue = False
        else:
            nouvel_iis = self._find_one_iis_and_zoom(&#39;quick_xplain&#39;)
            if len(nouvel_iis) == 0:
                on_continue = False
            else:
                mes_iis.append(nouvel_iis)
                self.list_already_found_iis.append(nouvel_iis)

    self.constraints_relaxation.inv_relax_all()
    return mes_iis</code></pre>
</details>
</dd>
<dt id="ortools_utils.explainability.negative_explanations.NegativeExplanation.find_set_of_distinct_iis_sa"><code class="name flex">
<span>def <span class="ident">find_set_of_distinct_iis_sa</span></span>(<span>self) ‑> [[<class '<a title="ortools_utils.model_indexation.constraints.NamedBlock" href="../model_indexation/constraints.html#ortools_utils.model_indexation.constraints.NamedBlock">NamedBlock</a>'>]]</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a set of IIS that do not intersect each other, with SA method</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def find_set_of_distinct_iis_sa(self) -&gt; [[NamedBlock]]:
    &#34;&#34;&#34;
    Returns a set of IIS that do not intersect each other, with SA method
    &#34;&#34;&#34;
    if not self.is_infeasible():
        return None

    mes_iis = []
    self.list_already_found_iis = []
    on_continue = True

    while on_continue:
        logger.info(&#39;Searching for a new IIS... &#39;)

        # On relache les contraintes des IIS déjà trouvés
        for iis in mes_iis:
            self.constraints_relaxation.relax_list_blocks(iis)

        # On vérifie qu&#39;on a encore au moins un conflit
        status = is_consistent(self.model, self.solver)

        if status:
            logger.info(&#39;No more IIS&#39;)
            on_continue = False
        else:
            mon_iis_uc = self._find_one_iis_and_zoom(&#39;sufficient_assumption&#39;)

            # On relache les contraintes des IIS déjà trouvés
            for iis in mes_iis:
                self.constraints_relaxation.relax_list_blocks(iis)

            logger.debug(&#39;IIS found with sufficient assumption:&#39;)
            logger.debug(mon_iis_uc)

            if not mon_iis_uc:
                mon_iis_uc = []

            self.constraints_relaxation.relax_all_real_constraints_but(mon_iis_uc)

            # Finds one IIS with sufficient assumption
            mes_blocks = mon_iis_uc + [b for b in self.dict_indexing.return_all_blocks_as_named() if not b.is_true_constraint()]
            mon_iis_complet = self._find_one_iis_and_zoom(&#39;quick_xplain&#39;, mes_blocks)

            logger.debug(&#39;Final IIS:&#39;)
            logger.debug(mon_iis_complet)

            if len(mon_iis_complet) == 0:
                on_continue = False
            else:
                mes_iis.append(mon_iis_complet)
                self.list_already_found_iis.append(mon_iis_complet)

    self.constraints_relaxation.inv_relax_all()
    return mes_iis</code></pre>
</details>
</dd>
<dt id="ortools_utils.explainability.negative_explanations.NegativeExplanation.inv_add_var_assumptions"><code class="name flex">
<span>def <span class="ident">inv_add_var_assumptions</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Function that removes ALL assumption variables</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def inv_add_var_assumptions(self):
    &#34;&#34;&#34;Function that removes ALL assumption variables&#34;&#34;&#34;
    # On enlève les variables assumptions présentes devant les contraintes
    for idx_constraints in self.list_idx_usual_constraints_with_assumptions:
        self.model.Proto().constraints[idx_constraints].enforcement_literal.pop(0)

    self.model.Proto().assumptions[:] = []

    # On supprime les variables d&#39;assumption
    for ind in sorted(self.variables_ajoutees, reverse=True):
        self.model.Proto().variables.pop(ind)

    # On remet à jour notre &#34;mémoire&#34;
    self.index_var_assumption_to_block = dict()
    self.block_to_index_var_assumption = dict()
    self.list_idx_usual_constraints_with_assumptions = []
    self.variables_ajoutees = []</code></pre>
</details>
</dd>
<dt id="ortools_utils.explainability.negative_explanations.NegativeExplanation.is_infeasible"><code class="name flex">
<span>def <span class="ident">is_infeasible</span></span>(<span>self) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Before searching for IIS, checks once and for all that the model is not feasible</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_infeasible(self) -&gt; bool:
    &#34;&#34;&#34;Before searching for IIS, checks once and for all that the model is not feasible&#34;&#34;&#34;
    self.model.Proto().ClearField(&#34;objective&#34;)
    return not is_consistent(self.model, self.solver)</code></pre>
</details>
</dd>
<dt id="ortools_utils.explainability.negative_explanations.NegativeExplanation.quick_xplain"><code class="name flex">
<span>def <span class="ident">quick_xplain</span></span>(<span>self, all_blocks) ‑> Optional[List[<a title="ortools_utils.model_indexation.constraints.NamedBlock" href="../model_indexation/constraints.html#ortools_utils.model_indexation.constraints.NamedBlock">NamedBlock</a>]]</span>
</code></dt>
<dd>
<div class="desc"><p>Function that implements the QuickXplain's algorithm
:return: result: (List[Block]) a list of blocks corresponding to an IIS</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def quick_xplain(self, all_blocks) -&gt; Union[List[NamedBlock], None]:
    &#34;&#34;&#34;
    Function that implements the QuickXplain&#39;s algorithm
    :return: result: (List[Block]) a list of blocks corresponding to an IIS
    &#34;&#34;&#34;
    logger.info(&#34;Launching quick_xplain&#34;)

    # list_of_usual_constraints_already_released = copy(self.constraints_relaxation.is_relaxed_usual_constraint)
    # list_of_constant_constraints_already_released = copy(self.constraints_relaxation.is_relaxed_constant)

    list_of_usual_constraints_already_released = {x: True for x in self.constraints_relaxation.is_relaxed_usual_constraint if self.constraints_relaxation.is_relaxed_usual_constraint[x]}
    list_of_constant_constraints_already_released = {x: True for x in self.constraints_relaxation.is_relaxed_constant if self.constraints_relaxation.is_relaxed_constant[x]}

    logger.debug(&#39;Relaxed constraints :&#39;)
    logger.debug(list(list_of_usual_constraints_already_released.keys()) + [&#39;c_{}&#39;.format(cons) for cons in list_of_constant_constraints_already_released.keys()])

    def QX(delta_bool: bool, remaining_constraints: List[NamedBlock], i_rec=1) -&gt; List[NamedBlock]:
        &#34;&#34;&#34;
        Core of the recursive function of QuickXplain&#39;s algorithm
        :param delta_bool: (bool) True if a constraint has just been activated, or False
        :param remaining_constraints: (List[Block]) remaining constraints for IIS research
        :param i_rec: (int) an iterator
        :return: delta_1 + delta_2: (List[Block]) a list of blocks corresponding to an IIS
        &#34;&#34;&#34;
        logger.debug(&#34;\t&#34; * i_rec + &#34;QX: remaining constraints %s&#34; % remaining_constraints)

        if delta_bool and not is_consistent(self.model, self.solver):
            logger.debug(&#34;\t&#34; * i_rec + &#34;QX: infeasible&#34;)
            return []
        if len(remaining_constraints) == 1:
            logger.debug(&#34;\t&#34; * i_rec + &#34;QX: only one remaining constraint&#34;)
            return remaining_constraints

        logger.debug(&#34;\t&#34; * i_rec + &#34;QX: feasible&#34;)

        C_1, C_2 = self.split(remaining_constraints, choice=self.split_choice)
        logger.debug(&#34;\t&#34; * i_rec + &#34;C1: %s, C2: %s&#34; % (C_1, C_2))

        self.constraints_relaxation.inv_relax_list_blocks(C_1, list_usual_idx_not_to_release=list_of_usual_constraints_already_released,
                                                          list_constant_idx_not_to_release=list_of_constant_constraints_already_released)
        logger.debug(&#34;\t&#34;*i_rec + &#34;QX: Activate C1 : %s&#34; % C_1)
        logger.debug(&#34;\t&#34;*i_rec + &#34;QX: Searches in C_2 after having reactivated C_1 : %s&#34; % C_1)
        delta_2 = QX(delta_bool=True, remaining_constraints=C_2, i_rec=i_rec + 1)
        logger.debug(&#34;\t&#34;*i_rec + &#34;QX: Delta_2 : %s&#34; % delta_2)
        self.constraints_relaxation.relax_list_blocks(C_1)
        logger.debug(&#34;\t&#34;*i_rec + &#34;QX: Deactivate C1 : %s&#34; % C_1)

        if delta_2 and len(delta_2) &gt; 0:
            logger.debug(&#34;\t&#34;*i_rec + &#34;QX: Activate Delta_2 : %s&#34; % delta_2)
            self.constraints_relaxation.inv_relax_list_blocks(delta_2, list_usual_idx_not_to_release=list_of_usual_constraints_already_released,
                                                              list_constant_idx_not_to_release=list_of_constant_constraints_already_released)
            logger.debug(&#34;\t&#34;*i_rec + &#34;QX: Searches in C_1 after having activated D2&#34;)
            delta_1 = QX(delta_bool=True, remaining_constraints=C_1, i_rec=i_rec + 1)
            logger.debug(&#34;\t&#34; * i_rec + &#34;QX: Delta_1 : %s&#34; % delta_1)

            logger.debug(&#34;\t&#34;*i_rec + &#34;QX: Deactivate Delta_2 : %s&#34; % delta_2)
            self.constraints_relaxation.relax_list_blocks(delta_2)
        else:
            logger.debug(&#34;\t&#34;*i_rec + &#34;QX: Searches in C_1&#34;)
            delta_1 = QX(delta_bool=False, remaining_constraints=C_1, i_rec=i_rec + 1)
            logger.debug(&#34;\t&#34; * i_rec + &#34;QX: Delta_1 : %s&#34; % delta_1)

        logger.debug(&#34;\t&#34;*i_rec + &#34;QX: Delta_1 + Delta_2 : %s&#34; % (delta_1 + delta_2))

        return delta_1 + delta_2

    if is_consistent(self.model, self.solver):
        logger.error(&#39;Quick Xplain was called but model is feasible&#39;)
        return None

    # all_blocks = [block for block in self.dict_indexing.splits_on_granularity()]

    logger.debug(&#39;List of blocks:&#39;)
    logger.debug(all_blocks)

    if len(all_blocks) == 0:
        return []

    logger.debug(&#34;QX: Deactivates all constraints: %s&#34; % all_blocks)
    self.constraints_relaxation.relax_list_blocks(all_blocks)
    result = QX(delta_bool=True, remaining_constraints=all_blocks)
    logger.debug(&#34;QX: Reactivates all constraints: %s&#34; % all_blocks)
    self.constraints_relaxation.inv_relax_list_blocks(all_blocks,
                                                      list_usual_idx_not_to_release=list_of_usual_constraints_already_released,
                                                      list_constant_idx_not_to_release=list_of_constant_constraints_already_released)
    return result</code></pre>
</details>
</dd>
<dt id="ortools_utils.explainability.negative_explanations.NegativeExplanation.split"><code class="name flex">
<span>def <span class="ident">split</span></span>(<span>self, C: List[<a title="ortools_utils.model_indexation.constraints.NamedBlock" href="../model_indexation/constraints.html#ortools_utils.model_indexation.constraints.NamedBlock">NamedBlock</a>], choice: int)</span>
</code></dt>
<dd>
<div class="desc"><p>Function that split the list C of constraint's blocks into two list of constraint's blocks
Beware if implementing new splitting methods. If the method occasionally return one empty list, quick_xplain will enter an infinite loop
:param C: (List[Block]) the list of constraint's blocks
:param choice: (int) 1 to "isolate" the first block
2 to split "by half"
3 to split in two and balance the size of both parts
:return: C_1, C_2: (List[Block]) two lists of constraint's blocks</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def split(self, C: List[NamedBlock], choice: int):
    # Attention à la méthode de découpage
    # S&#39;il n&#39;y a pas au moins un block dans chaque partie on va boucler à l&#39;infini
    &#34;&#34;&#34;
    Function that split the list C of constraint&#39;s blocks into two list of constraint&#39;s blocks
    Beware if implementing new splitting methods. If the method occasionally return one empty list, quick_xplain will enter an infinite loop
    :param C: (List[Block]) the list of constraint&#39;s blocks
    :param choice: (int) 1 to &#34;isolate&#34; the first block
                          2 to split &#34;by half&#34;
                          3 to split in two and balance the size of both parts
    :return: C_1, C_2: (List[Block]) two lists of constraint&#39;s blocks
    &#34;&#34;&#34;
    if choice == 1:
        return [C[0]], C[1:]
    if choice == 2:
        k = int(len(C) / 2)
        return C[:k], C[k:]
    if choice == 3:
        nb_blocs = len(C)
        if nb_blocs &lt; 2:
            return self.split(C, 2)

        mes_tailles = [b.size() for b in C]
        max_taille = sum(x for x in mes_tailles)

        &#34;&#34;&#34;On fait un mini problème d&#39;optimisation pour découper notre problème en deux parties égales&#34;&#34;&#34;
        model = cp_model.CpModel()
        solver2 = cp_model.CpSolver()
        solver2.parameters.max_time_in_seconds = 60
        affectations = {j: model.NewBoolVar(&#34;affect_{}&#34;.format(j)) for j in range(nb_blocs)}
        ecart_optimal = model.NewIntVar(0, max_taille, &#39;bloc_min&#39;)
        model.Add((2 * sum([affectations[j] * mes_tailles[j] for j in range(nb_blocs)]) - max_taille) &lt;= ecart_optimal)
        model.Add((max_taille - 2 * sum([affectations[j] * mes_tailles[j] for j in range(nb_blocs)])) &lt;= ecart_optimal)
        model.Minimize(ecart_optimal)
        res = solver2.Solve(model)

        if res == cp_model.OPTIMAL:
            bloc_1 = [C[j] for j in range(nb_blocs) if solver2.Value(affectations[j])]
            bloc_2 = [C[j] for j in range(nb_blocs) if not solver2.Value(affectations[j])]
            if len(bloc_2) == 0 or len(bloc_1) == 0:
                return self.split(C, 2)
            return bloc_1, bloc_2
        else:
            return self.split(C, 2)</code></pre>
</details>
</dd>
<dt id="ortools_utils.explainability.negative_explanations.NegativeExplanation.sufficient_assumption"><code class="name flex">
<span>def <span class="ident">sufficient_assumption</span></span>(<span>self, all_blocks) ‑> Optional[List[<a title="ortools_utils.model_indexation.constraints.NamedBlock" href="../model_indexation/constraints.html#ortools_utils.model_indexation.constraints.NamedBlock">NamedBlock</a>]]</span>
</code></dt>
<dd>
<div class="desc"><p>Function that returns an iis with the Or-tools function : "sufficient_assumptions_for_infeasibility"
:return: explanations: (List[Block]) a list of blocks corresponding to an IIS</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sufficient_assumption(self, all_blocks) -&gt; Union[List[NamedBlock], None]:
    &#34;&#34;&#34;
    Function that returns an iis with the Or-tools function : &#34;sufficient_assumptions_for_infeasibility&#34;
    :return: explanations: (List[Block]) a list of blocks corresponding to an IIS
    &#34;&#34;&#34;
    logger.info(&#34;Launching sufficient_assumption&#34;)
    self.add_var_assumptions(all_blocks)
    self.solver.parameters.num_search_workers = 1

    # On vérifie qu&#39;on a encore au moins un conflit
    status = is_consistent(self.model, self.solver)
    if status:
        self.inv_add_var_assumptions()
        return None
    else:
        assumptions = self.solver.ResponseProto().sufficient_assumptions_for_infeasibility
        explanations = set(self.index_var_assumption_to_block[index_b_var] for index_b_var in assumptions)
        self.inv_add_var_assumptions()
        return list(explanations)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="ortools_utils.explainability" href="index.html">ortools_utils.explainability</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="ortools_utils.explainability.negative_explanations.NegativeExplanation" href="#ortools_utils.explainability.negative_explanations.NegativeExplanation">NegativeExplanation</a></code></h4>
<ul class="">
<li><code><a title="ortools_utils.explainability.negative_explanations.NegativeExplanation.add_var_assumptions" href="#ortools_utils.explainability.negative_explanations.NegativeExplanation.add_var_assumptions">add_var_assumptions</a></code></li>
<li><code><a title="ortools_utils.explainability.negative_explanations.NegativeExplanation.find_iis_single_call" href="#ortools_utils.explainability.negative_explanations.NegativeExplanation.find_iis_single_call">find_iis_single_call</a></code></li>
<li><code><a title="ortools_utils.explainability.negative_explanations.NegativeExplanation.find_one_iis_auto_zoom_quick_xplain" href="#ortools_utils.explainability.negative_explanations.NegativeExplanation.find_one_iis_auto_zoom_quick_xplain">find_one_iis_auto_zoom_quick_xplain</a></code></li>
<li><code><a title="ortools_utils.explainability.negative_explanations.NegativeExplanation.find_one_iis_combined" href="#ortools_utils.explainability.negative_explanations.NegativeExplanation.find_one_iis_combined">find_one_iis_combined</a></code></li>
<li><code><a title="ortools_utils.explainability.negative_explanations.NegativeExplanation.find_one_iis_sufficient_assumption" href="#ortools_utils.explainability.negative_explanations.NegativeExplanation.find_one_iis_sufficient_assumption">find_one_iis_sufficient_assumption</a></code></li>
<li><code><a title="ortools_utils.explainability.negative_explanations.NegativeExplanation.find_set_of_distinct_iis_combined" href="#ortools_utils.explainability.negative_explanations.NegativeExplanation.find_set_of_distinct_iis_combined">find_set_of_distinct_iis_combined</a></code></li>
<li><code><a title="ortools_utils.explainability.negative_explanations.NegativeExplanation.find_set_of_distinct_iis_qx" href="#ortools_utils.explainability.negative_explanations.NegativeExplanation.find_set_of_distinct_iis_qx">find_set_of_distinct_iis_qx</a></code></li>
<li><code><a title="ortools_utils.explainability.negative_explanations.NegativeExplanation.find_set_of_distinct_iis_sa" href="#ortools_utils.explainability.negative_explanations.NegativeExplanation.find_set_of_distinct_iis_sa">find_set_of_distinct_iis_sa</a></code></li>
<li><code><a title="ortools_utils.explainability.negative_explanations.NegativeExplanation.inv_add_var_assumptions" href="#ortools_utils.explainability.negative_explanations.NegativeExplanation.inv_add_var_assumptions">inv_add_var_assumptions</a></code></li>
<li><code><a title="ortools_utils.explainability.negative_explanations.NegativeExplanation.is_infeasible" href="#ortools_utils.explainability.negative_explanations.NegativeExplanation.is_infeasible">is_infeasible</a></code></li>
<li><code><a title="ortools_utils.explainability.negative_explanations.NegativeExplanation.quick_xplain" href="#ortools_utils.explainability.negative_explanations.NegativeExplanation.quick_xplain">quick_xplain</a></code></li>
<li><code><a title="ortools_utils.explainability.negative_explanations.NegativeExplanation.split" href="#ortools_utils.explainability.negative_explanations.NegativeExplanation.split">split</a></code></li>
<li><code><a title="ortools_utils.explainability.negative_explanations.NegativeExplanation.sufficient_assumption" href="#ortools_utils.explainability.negative_explanations.NegativeExplanation.sufficient_assumption">sufficient_assumption</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>